// Code generated by protoc-gen-gogo.
// source: comet.proto
// DO NOT EDIT!

/*
	Package comet is a generated protocol buffer package.

	It is generated from these files:
		comet.proto

	It has these top-level messages:
		NoArgs
		NoReply
		PushMsgArg
		PushMsgsArg
		PushMsgsReply
		MPushMsgArg
		MPushMsgReply
		MPushMsgsArg
		MPushMsgsReply
		BoardcastArg
		BoardcastRoomArg
		RoomsReply
*/
package comet

import proto "github.com/golang/protobuf/proto"

// discarding unused import gogoproto "gogo/protobuf/gogoproto/gogo.pb"

import io "io"
import fmt "fmt"

import github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal

type NoArgs struct {
}

func (m *NoArgs) Reset()         { *m = NoArgs{} }
func (m *NoArgs) String() string { return proto.CompactTextString(m) }
func (*NoArgs) ProtoMessage()    {}

type NoReply struct {
}

func (m *NoReply) Reset()         { *m = NoReply{} }
func (m *NoReply) String() string { return proto.CompactTextString(m) }
func (*NoReply) ProtoMessage()    {}

type PushMsgArg struct {
	Key       string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Ver       int32  `protobuf:"varint,2,opt,name=ver,proto3" json:"ver,omitempty"`
	Operation int32  `protobuf:"varint,3,opt,name=operation,proto3" json:"operation,omitempty"`
	Msg       []byte `protobuf:"bytes,4,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *PushMsgArg) Reset()         { *m = PushMsgArg{} }
func (m *PushMsgArg) String() string { return proto.CompactTextString(m) }
func (*PushMsgArg) ProtoMessage()    {}

type PushMsgsArg struct {
	Key        string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Vers       []int32  `protobuf:"varint,2,rep,name=vers" json:"vers,omitempty"`
	Operations []int32  `protobuf:"varint,3,rep,name=operations" json:"operations,omitempty"`
	Msgs       [][]byte `protobuf:"bytes,4,rep,name=msgs" json:"msgs,omitempty"`
}

func (m *PushMsgsArg) Reset()         { *m = PushMsgsArg{} }
func (m *PushMsgsArg) String() string { return proto.CompactTextString(m) }
func (*PushMsgsArg) ProtoMessage()    {}

type PushMsgsReply struct {
	Index int32 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
}

func (m *PushMsgsReply) Reset()         { *m = PushMsgsReply{} }
func (m *PushMsgsReply) String() string { return proto.CompactTextString(m) }
func (*PushMsgsReply) ProtoMessage()    {}

type MPushMsgArg struct {
	Keys      []string `protobuf:"bytes,1,rep,name=keys" json:"keys,omitempty"`
	Ver       int32    `protobuf:"varint,2,opt,name=ver,proto3" json:"ver,omitempty"`
	Operation int32    `protobuf:"varint,3,opt,name=operation,proto3" json:"operation,omitempty"`
	Msg       []byte   `protobuf:"bytes,4,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *MPushMsgArg) Reset()         { *m = MPushMsgArg{} }
func (m *MPushMsgArg) String() string { return proto.CompactTextString(m) }
func (*MPushMsgArg) ProtoMessage()    {}

type MPushMsgReply struct {
	Index int32 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
}

func (m *MPushMsgReply) Reset()         { *m = MPushMsgReply{} }
func (m *MPushMsgReply) String() string { return proto.CompactTextString(m) }
func (*MPushMsgReply) ProtoMessage()    {}

type MPushMsgsArg struct {
	Keys       []string `protobuf:"bytes,1,rep,name=keys" json:"keys,omitempty"`
	Vers       []int32  `protobuf:"varint,2,rep,name=vers" json:"vers,omitempty"`
	Operations []int32  `protobuf:"varint,3,rep,name=operations" json:"operations,omitempty"`
	Msgs       [][]byte `protobuf:"bytes,4,rep,name=msgs" json:"msgs,omitempty"`
}

func (m *MPushMsgsArg) Reset()         { *m = MPushMsgsArg{} }
func (m *MPushMsgsArg) String() string { return proto.CompactTextString(m) }
func (*MPushMsgsArg) ProtoMessage()    {}

type MPushMsgsReply struct {
	Index int32 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
}

func (m *MPushMsgsReply) Reset()         { *m = MPushMsgsReply{} }
func (m *MPushMsgsReply) String() string { return proto.CompactTextString(m) }
func (*MPushMsgsReply) ProtoMessage()    {}

type BoardcastArg struct {
	Ver       int32  `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	Operation int32  `protobuf:"varint,2,opt,name=operation,proto3" json:"operation,omitempty"`
	Msg       []byte `protobuf:"bytes,3,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *BoardcastArg) Reset()         { *m = BoardcastArg{} }
func (m *BoardcastArg) String() string { return proto.CompactTextString(m) }
func (*BoardcastArg) ProtoMessage()    {}

type BoardcastRoomArg struct {
	Ver       int32  `protobuf:"varint,1,opt,name=ver,proto3" json:"ver,omitempty"`
	Operation int32  `protobuf:"varint,2,opt,name=operation,proto3" json:"operation,omitempty"`
	Msg       []byte `protobuf:"bytes,3,opt,name=msg,proto3" json:"msg,omitempty"`
	RoomId    int32  `protobuf:"varint,4,opt,name=roomId,proto3" json:"roomId,omitempty"`
}

func (m *BoardcastRoomArg) Reset()         { *m = BoardcastRoomArg{} }
func (m *BoardcastRoomArg) String() string { return proto.CompactTextString(m) }
func (*BoardcastRoomArg) ProtoMessage()    {}

type RoomsReply struct {
	Rooms map[int32]bool `protobuf:"bytes,1,rep,name=rooms" json:"rooms,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *RoomsReply) Reset()         { *m = RoomsReply{} }
func (m *RoomsReply) String() string { return proto.CompactTextString(m) }
func (*RoomsReply) ProtoMessage()    {}

func (m *RoomsReply) GetRooms() map[int32]bool {
	if m != nil {
		return m.Rooms
	}
	return nil
}

func init() {
}
func (m *NoArgs) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		switch fieldNum {
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipComet(data[iNdEx:])
			if err != nil {
				return err
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *NoReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		switch fieldNum {
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipComet(data[iNdEx:])
			if err != nil {
				return err
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *PushMsgArg) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Ver |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Operation |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipComet(data[iNdEx:])
			if err != nil {
				return err
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *PushMsgsArg) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vers", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Vers = append(m.Vers, v)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operations", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Operations = append(m.Operations, v)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msgs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msgs = append(m.Msgs, make([]byte, postIndex-iNdEx))
			copy(m.Msgs[len(m.Msgs)-1], data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipComet(data[iNdEx:])
			if err != nil {
				return err
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *PushMsgsReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Index |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipComet(data[iNdEx:])
			if err != nil {
				return err
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *MPushMsgArg) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Ver |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Operation |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipComet(data[iNdEx:])
			if err != nil {
				return err
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *MPushMsgReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Index |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipComet(data[iNdEx:])
			if err != nil {
				return err
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *MPushMsgsArg) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vers", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Vers = append(m.Vers, v)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operations", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Operations = append(m.Operations, v)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msgs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msgs = append(m.Msgs, make([]byte, postIndex-iNdEx))
			copy(m.Msgs[len(m.Msgs)-1], data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipComet(data[iNdEx:])
			if err != nil {
				return err
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *MPushMsgsReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Index |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipComet(data[iNdEx:])
			if err != nil {
				return err
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *BoardcastArg) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Ver |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Operation |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipComet(data[iNdEx:])
			if err != nil {
				return err
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *BoardcastRoomArg) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Ver |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Operation |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.RoomId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipComet(data[iNdEx:])
			if err != nil {
				return err
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *RoomsReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rooms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int32
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkey |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapvaluetemp int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapvaluetemp |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			mapvalue := bool(mapvaluetemp != 0)
			if m.Rooms == nil {
				m.Rooms = make(map[int32]bool)
			}
			m.Rooms[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipComet(data[iNdEx:])
			if err != nil {
				return err
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func skipComet(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for {
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipComet(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}
func (m *NoArgs) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *NoReply) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *PushMsgArg) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovComet(uint64(l))
	}
	if m.Ver != 0 {
		n += 1 + sovComet(uint64(m.Ver))
	}
	if m.Operation != 0 {
		n += 1 + sovComet(uint64(m.Operation))
	}
	if m.Msg != nil {
		l = len(m.Msg)
		if l > 0 {
			n += 1 + l + sovComet(uint64(l))
		}
	}
	return n
}

func (m *PushMsgsArg) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovComet(uint64(l))
	}
	if len(m.Vers) > 0 {
		for _, e := range m.Vers {
			n += 1 + sovComet(uint64(e))
		}
	}
	if len(m.Operations) > 0 {
		for _, e := range m.Operations {
			n += 1 + sovComet(uint64(e))
		}
	}
	if len(m.Msgs) > 0 {
		for _, b := range m.Msgs {
			l = len(b)
			n += 1 + l + sovComet(uint64(l))
		}
	}
	return n
}

func (m *PushMsgsReply) Size() (n int) {
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovComet(uint64(m.Index))
	}
	return n
}

func (m *MPushMsgArg) Size() (n int) {
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, s := range m.Keys {
			l = len(s)
			n += 1 + l + sovComet(uint64(l))
		}
	}
	if m.Ver != 0 {
		n += 1 + sovComet(uint64(m.Ver))
	}
	if m.Operation != 0 {
		n += 1 + sovComet(uint64(m.Operation))
	}
	if m.Msg != nil {
		l = len(m.Msg)
		if l > 0 {
			n += 1 + l + sovComet(uint64(l))
		}
	}
	return n
}

func (m *MPushMsgReply) Size() (n int) {
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovComet(uint64(m.Index))
	}
	return n
}

func (m *MPushMsgsArg) Size() (n int) {
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, s := range m.Keys {
			l = len(s)
			n += 1 + l + sovComet(uint64(l))
		}
	}
	if len(m.Vers) > 0 {
		for _, e := range m.Vers {
			n += 1 + sovComet(uint64(e))
		}
	}
	if len(m.Operations) > 0 {
		for _, e := range m.Operations {
			n += 1 + sovComet(uint64(e))
		}
	}
	if len(m.Msgs) > 0 {
		for _, b := range m.Msgs {
			l = len(b)
			n += 1 + l + sovComet(uint64(l))
		}
	}
	return n
}

func (m *MPushMsgsReply) Size() (n int) {
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovComet(uint64(m.Index))
	}
	return n
}

func (m *BoardcastArg) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovComet(uint64(m.Ver))
	}
	if m.Operation != 0 {
		n += 1 + sovComet(uint64(m.Operation))
	}
	if m.Msg != nil {
		l = len(m.Msg)
		if l > 0 {
			n += 1 + l + sovComet(uint64(l))
		}
	}
	return n
}

func (m *BoardcastRoomArg) Size() (n int) {
	var l int
	_ = l
	if m.Ver != 0 {
		n += 1 + sovComet(uint64(m.Ver))
	}
	if m.Operation != 0 {
		n += 1 + sovComet(uint64(m.Operation))
	}
	if m.Msg != nil {
		l = len(m.Msg)
		if l > 0 {
			n += 1 + l + sovComet(uint64(l))
		}
	}
	if m.RoomId != 0 {
		n += 1 + sovComet(uint64(m.RoomId))
	}
	return n
}

func (m *RoomsReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Rooms) > 0 {
		for k, v := range m.Rooms {
			_ = k
			_ = v
			mapEntrySize := 1 + sovComet(uint64(k)) + 1 + 1
			n += mapEntrySize + 1 + sovComet(uint64(mapEntrySize))
		}
	}
	return n
}

func sovComet(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozComet(x uint64) (n int) {
	return sovComet(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *NoArgs) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *NoArgs) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *NoReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *NoReply) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *PushMsgArg) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PushMsgArg) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintComet(data, i, uint64(len(m.Key)))
		i += copy(data[i:], m.Key)
	}
	if m.Ver != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintComet(data, i, uint64(m.Ver))
	}
	if m.Operation != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintComet(data, i, uint64(m.Operation))
	}
	if m.Msg != nil {
		if len(m.Msg) > 0 {
			data[i] = 0x22
			i++
			i = encodeVarintComet(data, i, uint64(len(m.Msg)))
			i += copy(data[i:], m.Msg)
		}
	}
	return i, nil
}

func (m *PushMsgsArg) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PushMsgsArg) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintComet(data, i, uint64(len(m.Key)))
		i += copy(data[i:], m.Key)
	}
	if len(m.Vers) > 0 {
		for _, num := range m.Vers {
			data[i] = 0x10
			i++
			i = encodeVarintComet(data, i, uint64(num))
		}
	}
	if len(m.Operations) > 0 {
		for _, num := range m.Operations {
			data[i] = 0x18
			i++
			i = encodeVarintComet(data, i, uint64(num))
		}
	}
	if len(m.Msgs) > 0 {
		for _, b := range m.Msgs {
			data[i] = 0x22
			i++
			i = encodeVarintComet(data, i, uint64(len(b)))
			i += copy(data[i:], b)
		}
	}
	return i, nil
}

func (m *PushMsgsReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PushMsgsReply) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintComet(data, i, uint64(m.Index))
	}
	return i, nil
}

func (m *MPushMsgArg) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *MPushMsgArg) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, s := range m.Keys {
			data[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.Ver != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintComet(data, i, uint64(m.Ver))
	}
	if m.Operation != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintComet(data, i, uint64(m.Operation))
	}
	if m.Msg != nil {
		if len(m.Msg) > 0 {
			data[i] = 0x22
			i++
			i = encodeVarintComet(data, i, uint64(len(m.Msg)))
			i += copy(data[i:], m.Msg)
		}
	}
	return i, nil
}

func (m *MPushMsgReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *MPushMsgReply) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintComet(data, i, uint64(m.Index))
	}
	return i, nil
}

func (m *MPushMsgsArg) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *MPushMsgsArg) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, s := range m.Keys {
			data[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.Vers) > 0 {
		for _, num := range m.Vers {
			data[i] = 0x10
			i++
			i = encodeVarintComet(data, i, uint64(num))
		}
	}
	if len(m.Operations) > 0 {
		for _, num := range m.Operations {
			data[i] = 0x18
			i++
			i = encodeVarintComet(data, i, uint64(num))
		}
	}
	if len(m.Msgs) > 0 {
		for _, b := range m.Msgs {
			data[i] = 0x22
			i++
			i = encodeVarintComet(data, i, uint64(len(b)))
			i += copy(data[i:], b)
		}
	}
	return i, nil
}

func (m *MPushMsgsReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *MPushMsgsReply) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintComet(data, i, uint64(m.Index))
	}
	return i, nil
}

func (m *BoardcastArg) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BoardcastArg) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintComet(data, i, uint64(m.Ver))
	}
	if m.Operation != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintComet(data, i, uint64(m.Operation))
	}
	if m.Msg != nil {
		if len(m.Msg) > 0 {
			data[i] = 0x1a
			i++
			i = encodeVarintComet(data, i, uint64(len(m.Msg)))
			i += copy(data[i:], m.Msg)
		}
	}
	return i, nil
}

func (m *BoardcastRoomArg) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BoardcastRoomArg) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ver != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintComet(data, i, uint64(m.Ver))
	}
	if m.Operation != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintComet(data, i, uint64(m.Operation))
	}
	if m.Msg != nil {
		if len(m.Msg) > 0 {
			data[i] = 0x1a
			i++
			i = encodeVarintComet(data, i, uint64(len(m.Msg)))
			i += copy(data[i:], m.Msg)
		}
	}
	if m.RoomId != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintComet(data, i, uint64(m.RoomId))
	}
	return i, nil
}

func (m *RoomsReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RoomsReply) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Rooms) > 0 {
		keysForRooms := make([]int32, 0, len(m.Rooms))
		for k, _ := range m.Rooms {
			keysForRooms = append(keysForRooms, k)
		}
		github_com_gogo_protobuf_sortkeys.Int32s(keysForRooms)
		for _, k := range keysForRooms {
			data[i] = 0xa
			i++
			v := m.Rooms[k]
			mapSize := 1 + sovComet(uint64(k)) + 1 + 1
			i = encodeVarintComet(data, i, uint64(mapSize))
			data[i] = 0x8
			i++
			i = encodeVarintComet(data, i, uint64(k))
			data[i] = 0x10
			i++
			if v {
				data[i] = 1
			} else {
				data[i] = 0
			}
			i++
		}
	}
	return i, nil
}

func encodeFixed64Comet(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Comet(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintComet(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
